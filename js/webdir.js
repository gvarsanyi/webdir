// Generated by CoffeeScript 1.9.3
(function() {
  var App, Boot, Server, args, express, fs, http, minimist, os, path, serve_index,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  http = require('http');

  os = require('os');

  path = require('path');

  express = require('express');

  serve_index = require('serve-index');

  minimist = require('minimist');

  args = minimist(process.argv.slice(2));

  App = (function() {
    function App(dir) {
      var arr, i, inf, len, name, ref, stat;
      this.dir = dir;
      this.dir = path.resolve(this.dir);
      console.log('[webroot]', this.dir);
      try {
        stat = fs.statSync(this.dir);
      } catch (_error) {}
      if (!(stat != null ? stat.isDirectory() : void 0)) {
        console.error('[not-a-isDirectory]', this.dir);
        return process.exit(1);
      }
      this.app = express();
      this.app.use('/', express["static"](this.dir));
      this.app.use('/', serve_index(this.dir, {
        icons: true
      }));
      this.ifaces = [];
      ref = os.networkInterfaces();
      for (name in ref) {
        arr = ref[name];
        for (i = 0, len = arr.length; i < len; i++) {
          inf = arr[i];
          if (inf.family === 'IPv4') {
            this.ifaces.push(inf.address);
          }
        }
      }
    }

    return App;

  })();

  Server = (function() {
    Server.pool = {};

    function Server(app1, iface1, port1) {
      this.app = app1;
      this.iface = iface1;
      this.port = port1;
      this.connect = bind(this.connect, this);
      this.id = this.iface + ':' + this.port;
      Server.pool[this.id] = this;
      console.log('[opening]', this.id);
      this.retries = 0;
      this.connect();
    }

    Server.prototype.connect = function() {
      this.timeout = null;
      if (this.retries >= 3) {
        console.error('[giving-up]', this.id);
        delete Server.pool[this.id];
        if (!Object.keys(Server.pool).length) {
          console.log('[exit] no service is listening');
          process.exit(1);
        }
        return;
      }
      this.server = http.createServer(this.app.app);
      this.server.listen(this.port, this.iface, (function(_this) {
        return function() {
          _this.retries = 0;
          return console.log('[listening]', _this.id);
        };
      })(this));
      this.server.on('error', (function(_this) {
        return function(err) {
          if (!_this.timeout) {
            _this.retries += 1;
            console.log('[error]', _this.id, err.code, '(retrying in 2 seconds)');
            return _this.timeout = setTimeout(_this.connect, 2000);
          }
        };
      })(this));
      return this.server.on('close', (function(_this) {
        return function() {
          if (!_this.timeout) {
            _this.retries += 1;
            console.log('[closed]', _this.id, '(reopening in 2 seconds)');
            return _this.timeout = setTimeout(_this.connect, 2000);
          }
        };
      })(this));
    };

    return Server;

  })();

  Boot = (function() {
    function Boot() {
      var _iface, _port, app, i, id, iface, ifaces, j, k, len, len1, len2, port, ports, ref, ref1;
      app = new App(args.dir || args.d || process.cwd());
      ref = args._;
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        ref1 = id.split(':'), iface = ref1[0], port = ref1[1];
        iface = iface || args.iface || args.i || '*';
        if (iface === '*') {
          ifaces = app.ifaces;
        } else {
          ifaces = iface.split(',');
        }
        ports = (port || args.port || args.p || '1080').split(',');
        for (j = 0, len1 = ifaces.length; j < len1; j++) {
          _iface = ifaces[j];
          for (k = 0, len2 = ports.length; k < len2; k++) {
            _port = ports[k];
            if (!Server.pool[_iface + ':' + _port]) {
              new Server(app, _iface, _port);
            }
          }
        }
      }
    }

    return Boot;

  })();

  new Boot;

  if (!Object.keys(Server.pool).length) {
    console.error('[exit] missing interface or port spec');
    process.exit(1);
  }

}).call(this);
